/*
 * gulp-tomcat
 *
 *
 * Copyright (c) 2016 Santiago Varela
 * Licensed under the MIT license.
 */

'use strict';

var gulp = require('gulp'),
  gutil = require('gulp-util'),
  spawn = require('cross-spawn'),
  which = require('which'),
  fs = require('fs'),
  http = require('http'),
  q = require('q'),
  options = require('./options.json');

var server = (function() {

  server = function() {
    this.urlCfg = null;
    this.ignoredApps = ['ROOT', 'manager', 'docs', 'examples', 'host-manager'];
    this.urlCfg = {
      hostname: options.tomcatHostname,
      path: null,
      port: options.tomcatPort,
      headers: {
        "Authorization": 'Basic ' + new Buffer(options.tomcatUsername + ":" + options.tomcatPassword).toString('base64')
      }
    };
  }

  var checkBinary = function(cmd, errMsg) {
    try {
      which.sync(cmd);
    } catch (err) {
      return new Error('\n' + errMsg + '\n');
    }
  }

  // 'Start / Stop Catalina Server'
  server.prototype.toggle = function(cmd) {
    var bin = 'catalina',
        path = options.start || options.stop;
    if(path) {
      if (fs.stat(path), function(err, stat) {
          if (err == null) {
            gutil.log("\nPath to Catalina found!\n");
          } else {
            return gutil.log("\nPath to Catalina does not exist.\n");
          }
      });
    }
    else {
      checkBinary(bin,
      'You need to have Catalina installed and in your PATH for this task to work.'
      );
    }
    bin = path;
    gutil.log('Command: ' + bin + ' ' + cmd);
    spawn(bin, [cmd], {
      stdio: 'inherit'
    });
  }

  server.prototype.deploy = function(applicationName) {
    var defer = q.defer();
    this.get("upload?path=" + options.location + applicationName).then(function(data) {
      if (data.length >= 4 && data.substr(0, 4) == "FAIL") {
        defer.reject(data);
        return;
      }
      defer.resolve(applicationName);
    }, function(err) {
      defer.reject(err);
    });
    return defer.promise;
  }

  server.prototype.get = function(path) {
    var resp = '';
    var defer = q.defer();

    this.urlCfg.path = '/manager/text/' + path;
    gutil.log(this.urlCfg.path);

    var request = http.request(this.urlCfg, function(res) {
      res.on('data', function(chunk) {
        resp += chunk;
      });
      res.on('end', function() {
        defer.resolve(resp);
      });
    });
    request.on('error', function(e) {
      defer.reject(e);
    });
    request.end();
  }

  return server;
})();

server = new server();
module.exports = server;
